<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SƒÉn t·ª© linh - C·∫•u h√¨nh Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .content {
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            transform: scale(1.2);
        }

        .rules-list {
            list-style: none;
            padding-left: 0;
        }

        .rules-list li {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #27ae60;
        }

        .rule-item {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: transform 0.2s;
        }

        .rule-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .rule-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .rule-header h3 {
            color: #2c3e50;
            margin: 0;
        }

        .priority-badge {
            background: #3498db;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .pattern-display {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .pattern-item {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .bet-amounts {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .bet-amount {
            background: #27ae60;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .file-input {
            display: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            /* increased modal width from 600px to 800px */
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        .pattern-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .pattern-input input {
            width: 60px;
            text-align: center;
        }

        .bet-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .bet-option input[type="checkbox"] {
            transform: scale(1.2);
        }

        .bet-option input[type="number"] {
            width: 150px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }

            .content {
                padding: 20px;
            }

            .buttons {
                flex-direction: column;
            }

            .rule-header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .form-row {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üê≤ SƒÉn R·ªìng</h1>
            <p>C·∫•u h√¨nh Game v√† Chi·∫øn thu·∫≠t C∆∞·ª£c</p>
        </div>

        <div class="content">
            <div class="section">
                <h2>‚öôÔ∏è C√†i ƒë·∫∑t Game</h2>
                <div class="form-group">
                    <label>üí∞ S·ªë ti·ªÅn c∆∞·ª£c m·ªói l·∫ßn:</label>
                    <input type="number" id="betAmount" value="1000" min="100" step="100">
                </div>
                <div class="form-group">
                    <label>üé∞ Ng∆∞·ª°ng Jackpot:</label>
                    <input type="number" id="jackpotThreshold" value="500000" min="10000" step="10000">
                </div>
                <div class="form-group">
                    <label>üõë D·ª´ng c∆∞·ª£c khi thua:</label>
                    <input type="number" id="betStop" value="10000" min="1000" step="1000">
                </div>
                <div class="form-group">
                    <label>‚è±Ô∏è Th·ªùi gian g·ª≠i tin nh·∫Øn (gi√¢y):</label>
                    <input type="number" id="timeSendMess" value="1" min="1" max="10">
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="isMartingale">
                        <label for="isMartingale">üìà S·ª≠ d·ª•ng chi·∫øn thu·∫≠t Martingale</label>
                    </div>
                </div>
                <div class="form-group">
                    <label>üìä T·ª∑ l·ªá Martingale:</label>
                    <input type="number" id="rateMartingale" value="2" min="1.5" max="5" step="0.1">
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="zombie" checked>
                        <label for="zombie">üßü Ch·∫ø ƒë·ªô Zombie (t·ª± ƒë·ªông)</label>
                    </div>
                </div>
            </div>

            <div class="section betting-rules">
                <h2>üéØ Quy t·∫Øc c∆∞·ª£c</h2>
            </div>

            <div class="buttons">
                <button class="btn btn-success" onclick="saveConfig()">
                    üíæ L∆∞u c·∫•u h√¨nh
                </button>
                <button class="btn btn-danger" onclick="resetConfig()">
                    üîÑ Reset v·ªÅ m·∫∑c ƒë·ªãnh
                </button>
            </div>

            <input type="file" id="configFileInput" class="file-input" accept=".json"
                onchange="loadConfigFromFile(event)">

            <div id="status" class="status"></div>
        </div>
    </div>

    <!-- Add/Edit Rule Modal -->
    <div id="ruleModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">‚ûï Th√™m quy t·∫Øc c∆∞·ª£c m·ªõi</h2>
                <span class="close" onclick="closeAddRuleForm()">&times;</span>
            </div>

            <form id="ruleForm">
                <div class="form-group">
                    <label>üìù M√¥ t·∫£ quy t·∫Øc:</label>
                    <input type="text" id="ruleDescription" placeholder="V√≠ d·ª•: C∆∞·ª£c CH·∫¥N khi c√≥ pattern CH·∫¥N-L·∫∫"
                        required>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>üî¢ ƒê·ªô ∆∞u ti√™n:</label>
                        <input type="number" id="rulePriority" value="1" min="1" max="10">
                    </div>
                </div>

                <div class="form-group">
                    <label>üé≤ Pattern v·ªã tr√≠ (t√πy ch·ªçn):</label>
                    <div id="patternInputs">
                        <!-- Pattern inputs will be dynamically generated here -->
                    </div>
                    <small>Nh·∫•p v√†o Ch·∫µn ho·∫∑c L·∫ª ƒë·ªÉ th√™m v√†o pattern. T·ªëi ƒëa 10 v·ªã tr√≠.</small>
                </div>

                <div class="form-group">
                    <label>üéØ Lo·∫°i c∆∞·ª£c:</label>
                    <div id="betOptions">
                        <!-- Bet options will be dynamically generated here -->
                    </div>
                </div>

                <div class="buttons">
                    <button type="button" class="btn btn-success" onclick="saveRule()">üíæ L∆∞u quy t·∫Øc</button>
                    <button type="button" class="btn btn-danger" onclick="closeAddRuleForm()">‚ùå H·ªßy</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const API_BASE_URL = "http://localhost:3000/api/config/shake-disk";
        const AVAILABLE_COLORS = ["CH·∫¥N", "L·∫∫"];
        const MAX_PATTERN_COLORS = 10;

        const BET_OPTIONS = [
            { label: "Ch·∫µn (1:2)", value: "2", ui: [true] },
            { label: "L·∫ª (1:2)", value: "5", ui: [false] },
            { label: "Ch·∫µn (1:4)", value: "1", ui: [false, true, true, true] },
            { label: "L·∫ª (1:4)", value: "3", ui: [true, false, false, false] },
            { label: "Ch·∫µn (1:16)", value: "0", ui: [true, true, true, true] },
            { label: "L·∫ª (1:16)", value: "4", ui: [false, false, false, false] }
        ];

        let currentConfig = {
            gameSettings: {},
            bettingRules: []
        };
        let editingRuleIndex = -1;
        let currentPattern = [];
        const MAX_PATTERN_LENGTH = 10;

        document.addEventListener('DOMContentLoaded', function () {
            loadConfigFromServer();
            setupFormSync();
        });

        // --- Load config t·ª´ server ---
        async function loadConfigFromServer() {
            try {
                const response = await fetch(API_BASE_URL);
                if (!response.ok) throw new Error("Kh√¥ng th·ªÉ t·∫£i config t·ª´ server");

                const config = await response.json();
                currentConfig = config;
                updateFormFromConfig(config);
                updateBettingRulesDisplay(config.bettingRules || []);

                showStatus("‚úÖ ƒê√£ t·∫£i c·∫•u h√¨nh t·ª´ server!", "success");
            } catch (error) {
                currentConfig = {
                    gameSettings: {
                        "BET_AMOUNT": 1000,
                        "JACKPOT_THRESHOLD": 500000,
                        "BET_STOP": 10000,
                        "TIME_SEND_MESS": 1,
                        "IS_MARTINGALE": false,
                        "RATE_MARTINGALE": 2,
                        "ZOMBIE": true
                    },
                    bettingRules: [
                        {
                            "betOn": "2",
                            "priority": 10,
                            "active": true,
                            "description": "CH·∫¥N ‚Üí L·∫∫ c∆∞·ª£c CH·∫¥N v·ªõi t·ª∑ l·ªá 1:2.",
                            "betAmount": 5000,
                            "pattern": ["CH·∫¥N", "L·∫∫"]
                        },
                        {
                            "betOn": ["1", "3"],
                            "priority": 0,
                            "active": true,
                            "description": "Default rule: n·∫øu kh√¥ng kh·ªõp pattern n√†o th√¨ c∆∞·ª£c CH·∫¥N v·ªõi t·ª∑ l·ªá 1:4 v√† L·∫∫ v·ªõi t·ª∑ l·ªá 1:4.",
                            "betAmount": [1000, 2000],
                            "pattern": []
                        }
                    ]
                };
                updateFormFromConfig(currentConfig);
                updateBettingRulesDisplay(currentConfig.bettingRules);
                showStatus("‚ö†Ô∏è S·ª≠ d·ª•ng c·∫•u h√¨nh m·∫∑c ƒë·ªãnh (kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c server)", "error");
            }
        }

        function updateFormFromConfig(config) {
            const settings = config.gameSettings;
            document.getElementById('betAmount').value = settings.BET_AMOUNT || 1000;
            document.getElementById('jackpotThreshold').value = settings.JACKPOT_THRESHOLD || 500000;
            document.getElementById('betStop').value = settings.BET_STOP || 10000;
            document.getElementById('timeSendMess').value = settings.TIME_SEND_MESS || 1;
            document.getElementById('isMartingale').checked = settings.IS_MARTINGALE || false;
            document.getElementById('rateMartingale').value = settings.RATE_MARTINGALE || 2;
            document.getElementById('zombie').checked = settings.ZOMBIE !== false;
        }

        function updateConfigFromForm() {
            currentConfig.gameSettings = {
                "BET_AMOUNT": parseInt(document.getElementById('betAmount').value),
                "JACKPOT_THRESHOLD": parseInt(document.getElementById('jackpotThreshold').value),
                "BET_STOP": parseInt(document.getElementById('betStop').value),
                "TIME_SEND_MESS": parseInt(document.getElementById('timeSendMess').value),
                "IS_MARTINGALE": document.getElementById('isMartingale').checked,
                "RATE_MARTINGALE": parseFloat(document.getElementById('rateMartingale').value),
                "ZOMBIE": document.getElementById('zombie').checked
            };
        }

        // --- Save config v·ªÅ server ---
        async function saveConfig() {
            try {
                updateConfigFromForm();

                const response = await fetch(API_BASE_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(currentConfig, null, 4)
                });

                if (!response.ok) throw new Error("Server tr·∫£ l·ªói");

                showStatus("‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh th√†nh c√¥ng l√™n server!", "success");
            } catch (error) {
                showStatus("‚ùå L·ªói khi l∆∞u: " + error.message, "error");
            }
        }

        // --- Reset config ---
        async function resetConfig() {
            if (!confirm("üîÑ B·∫°n c√≥ ch·∫Øc mu·ªën reset v·ªÅ c·∫•u h√¨nh m·∫∑c ƒë·ªãnh?")) return;
            try {
                const response = await fetch(API_BASE_URL + "/reset", { method: "POST" });
                if (!response.ok) throw new Error("Server tr·∫£ l·ªói reset");

                const defaultConfig = await response.json();
                currentConfig = defaultConfig;
                updateFormFromConfig(defaultConfig);
                updateBettingRulesDisplay(defaultConfig.bettingRules || []);

                showStatus("üîÑ ƒê√£ reset v·ªÅ c·∫•u h√¨nh m·∫∑c ƒë·ªãnh t·ª´ server!", "success");
            } catch (error) {
                // Fallback reset
                currentConfig.bettingRules = [];
                updateBettingRulesDisplay([]);
                showStatus("üîÑ ƒê√£ x√≥a t·∫•t c·∫£ quy t·∫Øc c∆∞·ª£c!", "success");
            }
        }

        // --- Betting Rules Management ---
        function updateBettingRulesDisplay(bettingRules) {
            const bettingSection = document.querySelector('.betting-rules');
            const existingRules = bettingSection.querySelectorAll('.rule-item');
            existingRules.forEach(rule => rule.remove());

            // Remove existing add button
            const existingAddBtn = bettingSection.querySelector('.btn-primary');
            if (existingAddBtn) existingAddBtn.remove();

            bettingRules.forEach((rule, index) => {
                const ruleDiv = document.createElement('div');
                ruleDiv.className = 'rule-item';
                ruleDiv.innerHTML = `
                    <div class="rule-header">
                        <h3>Quy t·∫Øc ${index + 1} ${rule.active ? '‚úÖ' : '‚ùå'}</h3>
                        <div>
                            <span class="priority-badge">∆Øu ti√™n: ${rule.priority}</span>
                            <button class="btn btn-warning" onclick="editRule(${index})" style="padding: 5px 10px; font-size: 12px; margin-left: 10px;">‚úèÔ∏è S·ª≠a</button>
                            <button class="btn btn-danger" onclick="deleteRule(${index})" style="padding: 5px 10px; font-size: 12px; margin-left: 5px;">üóëÔ∏è X√≥a</button>
                        </div>
                    </div>
                    <p><strong>M√¥ t·∫£:</strong> ${rule.description}</p>
                    ${rule.pattern && rule.pattern.length > 0 ? `
                        <p><strong>Pattern v·ªã tr√≠:</strong></p>
                        <div class="pattern-display">
                            ${rule.pattern.map(color => `<span class="pattern-item" style="background-color: ${getColorCode(color)}">${color}</span>`).join('')}
                        </div>
                    ` : '<p><strong>Pattern:</strong> Kh√¥ng c√≥ pattern c·ª• th·ªÉ</p>'}
                    <p><strong>C∆∞·ª£c v√†o:</strong> ${Array.isArray(rule.betOn) ? rule.betOn.map(option => option.split('_')[0]).join(', ') : rule.betOn.split('_')[0]}</p>
                    <div class="bet-amounts">
                        ${Array.isArray(rule.betAmount) ?
                        rule.betAmount.map((amount, i) => `<span class="bet-amount">${Array.isArray(rule.betOn) ? rule.betOn[i].split('_')[0] : 'C∆∞·ª£c'}: ${amount.toLocaleString()} VNƒê</span>`).join('') :
                        `<span class="bet-amount">${rule.betAmount.toLocaleString()} VNƒê</span>`
                    }
                    </div>
                `;
                bettingSection.appendChild(ruleDiv);
            });

            const addRuleBtn = document.createElement('button');
            addRuleBtn.className = 'btn btn-primary';
            addRuleBtn.innerHTML = '‚ûï Th√™m quy t·∫Øc c∆∞·ª£c m·ªõi';
            addRuleBtn.onclick = showAddRuleForm;
            bettingSection.appendChild(addRuleBtn);
        }

        function getColorCode(colorName) {
            const colorMap = {
                'CH·∫¥N': '#27ae60',  // Green for even
                'L·∫∫': '#e74c3c',    // Red for odd
            };
            return colorMap[colorName] || '#95a5a6';
        }

        function showAddRuleForm() {
            editingRuleIndex = -1;
            document.getElementById('modalTitle').textContent = '‚ûï Th√™m quy t·∫Øc c∆∞·ª£c m·ªõi';
            clearRuleForm();
            updatePatternInputs();
            updateBetOptions();
            document.getElementById('ruleModal').style.display = 'block';
        }

        function updatePatternInputs() {
            const patternContainer = document.getElementById('patternInputs');
            patternContainer.innerHTML = `
                <div class="pattern-input">
                    <label>Ch·ªçn v·ªã tr√≠ ch·∫µn/l·∫ª cho pattern (t·ªëi ƒëa ${MAX_PATTERN_LENGTH} v·ªã tr√≠):</label>
                    <div id="selectedPattern" style="display: flex; flex-wrap: wrap; gap: 5px; margin: 10px 0; min-height: 40px; border: 2px dashed #e9ecef; border-radius: 8px; padding: 10px; align-items: center;">
                        <span id="patternPlaceholder" style="color: #6c757d; font-style: italic;">Nh·∫•p v√†o Ch·∫µn ho·∫∑c L·∫ª b√™n d∆∞·ªõi ƒë·ªÉ t·∫°o pattern...</span>
                    </div>
                    <div id="colorPalette" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;">
                        ${AVAILABLE_COLORS.map(color => `
                            <button type="button" class="color-btn" data-color="${color}" 
                                style="background-color: ${getColorCode(color)}; 
                                       color: white; 
                                       border: 3px solid transparent;
                                       padding: 15px 25px; 
                                       border-radius: 8px; 
                                       font-weight: bold; 
                                       cursor: pointer;
                                       transition: all 0.3s;
                                       min-width: 100px;
                                       font-size: 16px;"
                                onclick="addColorToPattern('${color}')"
                                onmouseover="this.style.transform='scale(1.05)'"
                                onmouseout="this.style.transform='scale(1)'">${color}</button>
                        `).join('')}
                    </div>
                    <small>Nh·∫•p v√†o Ch·∫µn ho·∫∑c L·∫ª ƒë·ªÉ th√™m v√†o pattern. T·ªëi ƒëa ${MAX_PATTERN_LENGTH} v·ªã tr√≠.</small>
                </div>
            `;
        }

        function updateBetOptions() {
            const betOptionsContainer = document.getElementById('betOptions');
            betOptionsContainer.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <label><strong>Ch·ªçn lo·∫°i c∆∞·ª£c v·ªõi t·ª∑ l·ªá:</strong></label>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                        ${BET_OPTIONS.map(option => {
                // Generate visual display based on ui array
                let visualDisplay = '';
                if (option.ui.length === 1) {
                    // Show label text for single element
                    visualDisplay = `<span style="font-weight: bold; font-size: 14px;">${option.label}</span>`;
                } else {
                    // Show dots for multiple elements
                    const dots = option.ui.map(isRed => {
                        const color = isRed ? '#e74c3c' : '#ffffff';
                        const border = isRed ? 'none' : '2px solid #95a5a6';
                        return `<div style="width: 20px; height: 20px; border-radius: 50%; background-color: ${color}; border: ${border}; display: inline-block;"></div>`;
                    }).join('');
                    visualDisplay = `
                                    <div style="display: flex; gap: 5px; align-items: center;">
                                        ${dots}
                                        <span style="margin-left: 8px; font-size: 12px; color: #6c757d;">${option.label}</span>
                                    </div>
                                `;
                }

                return `
                            <div class="bet-option" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 2px solid #e9ecef;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="checkbox" id="bet${option.value}" value="${option.value}" style="transform: scale(1.3);">
                                    <label for="bet${option.value}" style="margin: 0; min-width: 150px; display: flex; align-items: center;">
                                        ${visualDisplay}
                                    </label>
                                    <input type="number" id="amount${option.value}" placeholder="S·ªë ti·ªÅn c∆∞·ª£c" min="1000" step="1000" style="flex: 1; padding: 10px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px;">
                                </div>
                            </div>
                        `}).join('')}
                    </div>
                </div>
            `;
        }

        function addColorToPattern(color) {
            if (currentPattern.length >= MAX_PATTERN_LENGTH) {
                alert(`Ch·ªâ ƒë∆∞·ª£c ch·ªçn t·ªëi ƒëa ${MAX_PATTERN_LENGTH} v·ªã tr√≠ cho pattern!`);
                return;
            }

            console.log("[v0] Adding color to pattern:", color);
            currentPattern.push(color);
            console.log("[v0] Current pattern after adding:", currentPattern);

            updatePatternDisplay();
            updatePatternDescription();
        }

        function updatePatternDisplay() {
            const patternContainer = document.getElementById('selectedPattern');
            const placeholder = document.getElementById('patternPlaceholder');

            console.log("[v0] Updating pattern display, current pattern:", currentPattern);

            // Remove existing pattern items first
            const existingItems = patternContainer.querySelectorAll('.pattern-color-item');
            existingItems.forEach(item => item.remove());

            if (currentPattern.length === 0) {
                console.log("[v0] No pattern items, showing placeholder");
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
                return;
            }

            if (placeholder) {
                placeholder.style.display = 'none';
            }

            // Add pattern items
            currentPattern.forEach((color, index) => {
                const colorItem = document.createElement('div');
                colorItem.className = 'pattern-color-item';
                colorItem.style.cssText = `
                    background-color: ${getColorCode(color)};
                    color: white;
                    padding: 10px 15px;
                    border-radius: 6px;
                    font-weight: bold;
                    font-size: 15px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    position: relative;
                `;

                colorItem.innerHTML = `
                    <span>V·ªã tr√≠ ${index + 1}: ${color}</span>
                    <button type="button" onclick="removeColorFromPattern(${index})" 
                        style="background: rgba(255,255,255,0.3); border: none; border-radius: 50%; width: 22px; height: 22px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; color: white; font-weight: bold;">√ó</button>
                `;

                patternContainer.appendChild(colorItem);
            });

            console.log("[v0] Pattern display updated with", currentPattern.length, "items");
        }

        function removeColorFromPattern(index) {
            console.log("[v0] Removing color at index:", index, "Current pattern:", currentPattern);
            currentPattern.splice(index, 1);
            console.log("[v0] Pattern after removal:", currentPattern);

            updatePatternDisplay();
            updatePatternDescription();

            if (currentPattern.length === 0) {
                console.log("[v0] Last item removed, ensuring placeholder is shown");
                setTimeout(() => {
                    const patternContainer = document.getElementById('selectedPattern');
                    const placeholder = document.getElementById('patternPlaceholder');
                    if (placeholder) {
                        placeholder.style.display = 'block';
                        console.log("[v0] Placeholder shown after timeout");
                    }
                    // Remove any remaining pattern items
                    const existingItems = patternContainer.querySelectorAll('.pattern-color-item');
                    existingItems.forEach(item => item.remove());
                }, 10);
            }
        }

        function updatePatternDescription() {
            console.log("[v0] updatePatternDescription called, currentPattern:", currentPattern);
            const descriptionInput = document.getElementById('ruleDescription');
            if (!descriptionInput) {
                console.log("[v0] Description input not found");
                return;
            }

            if (currentPattern.length > 0) {
                const patternDescription = currentPattern.join('-');
                console.log("[v0] Pattern description generated:", patternDescription);
                // Always update the description field with the pattern
                descriptionInput.value = patternDescription;
                console.log("[v0] Description field updated:", descriptionInput.value);
            } else {
                // Clear description when pattern is empty
                descriptionInput.value = '';
                console.log("[v0] Description cleared for empty pattern");
            }
        }

        function saveRule() {
            const description = document.getElementById('ruleDescription').value.trim();
            const priority = parseInt(document.getElementById('rulePriority').value);

            if (!description) {
                alert('Vui l√≤ng nh·∫≠p m√¥ t·∫£ quy t·∫Øc!');
                return;
            }

            // Use currentPattern instead of checkbox selection
            const selectedPatternColors = [...currentPattern];

            const betOn = [];
            const betAmount = [];

            BET_OPTIONS.forEach(option => {
                const checkbox = document.getElementById(`bet${option.value}`);
                const amountInput = document.getElementById(`amount${option.value}`);

                if (checkbox && checkbox.checked && amountInput && amountInput.value) {
                    betOn.push(option.value);
                    betAmount.push(parseInt(amountInput.value));
                }
            });

            if (betOn.length === 0) {
                alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt lo·∫°i c∆∞·ª£c v√† nh·∫≠p s·ªë ti·ªÅn!');
                return;
            }

            const newRule = {
                description: description,
                priority: priority,
                active: true,
                pattern: selectedPatternColors,
                betOn: betOn, // Always keep as array
                betAmount: betAmount // Always keep as array
            };

            if (editingRuleIndex >= 0) {
                // Edit existing rule
                currentConfig.bettingRules[editingRuleIndex] = newRule;
                showStatus('‚úÖ ƒê√£ c·∫≠p nh·∫≠t quy t·∫Øc c∆∞·ª£c!', 'success');
            } else {
                // Add new rule
                if (!currentConfig.bettingRules) currentConfig.bettingRules = [];
                currentConfig.bettingRules.push(newRule);
                showStatus('‚úÖ ƒê√£ th√™m quy t·∫Øc c∆∞·ª£c m·ªõi!', 'success');
            }

            // Sort rules by priority (higher priority first)
            currentConfig.bettingRules.sort((a, b) => b.priority - a.priority);

            updateBettingRulesDisplay(currentConfig.bettingRules);
            closeAddRuleForm();
        }

        function editRule(index) {
            editingRuleIndex = index;
            const rule = currentConfig.bettingRules[index];

            document.getElementById('modalTitle').textContent = '‚úèÔ∏è S·ª≠a quy t·∫Øc c∆∞·ª£c';
            document.getElementById('ruleDescription').value = rule.description;
            document.getElementById('rulePriority').value = rule.priority;

            updatePatternInputs();
            updateBetOptions();

            // Load existing pattern into currentPattern
            currentPattern = rule.pattern ? [...rule.pattern] : [];
            updatePatternDisplay();

            const betOn = Array.isArray(rule.betOn) ? rule.betOn : [rule.betOn];
            const betAmount = Array.isArray(rule.betAmount) ? rule.betAmount : [rule.betAmount];

            betOn.forEach((betValue, i) => {
                const checkbox = document.getElementById(`bet${betValue}`);
                const amountInput = document.getElementById(`amount${betValue}`);
                if (checkbox) checkbox.checked = true;
                if (amountInput) amountInput.value = betAmount[i] || betAmount[0];
            });

            document.getElementById('ruleModal').style.display = 'block';
        }

        function closeAddRuleForm() {
            document.getElementById('ruleModal').style.display = 'none';
            clearRuleForm();
        }

        function clearRuleForm() {
            document.getElementById('ruleForm').reset();
            document.getElementById('rulePriority').value = 1;
            currentPattern = [];
            if (document.getElementById('selectedPattern')) {
                updatePatternDisplay();
            }
        }

        function deleteRule(index) {
            if (!confirm('üóëÔ∏è B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a quy t·∫Øc n√†y?')) return;

            currentConfig.bettingRules.splice(index, 1);
            updateBettingRulesDisplay(currentConfig.bettingRules);
            showStatus('üóëÔ∏è ƒê√£ x√≥a quy t·∫Øc c∆∞·ª£c!', 'success');
        }

        // --- Form sync ---
        function setupFormSync() {
            const formInputs = [
                'betAmount', 'jackpotThreshold', 'betStop', 'timeSendMess',
                'isMartingale', 'rateMartingale', 'zombie'
            ];
            formInputs.forEach(inputId => {
                const element = document.getElementById(inputId);
                if (element) {
                    element.addEventListener('input', function () {
                        clearTimeout(window.formSyncTimeout);
                        window.formSyncTimeout = setTimeout(() => {
                            updateConfigFromForm();
                        }, 500);
                    });
                }
            });
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            setTimeout(() => { statusDiv.style.display = 'none'; }, 5000);
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('ruleModal');
            if (event.target === modal) {
                closeAddRuleForm();
            }
        }
    </script>
</body>

</html>