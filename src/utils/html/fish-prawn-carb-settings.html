<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üê≤ SƒÉn R·ªìng - C·∫•u h√¨nh Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .content {
            padding: 30px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            transform: scale(1.2);
        }

        .rules-list {
            list-style: none;
            padding-left: 0;
        }

        .rules-list li {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #27ae60;
        }

        .rule-item {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: transform 0.2s;
        }

        .rule-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .rule-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .rule-header h3 {
            color: #2c3e50;
            margin: 0;
        }

        .priority-badge {
            background: #3498db;
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }

        .pattern-display {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }

        .pattern-item {
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        .bet-amounts {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .bet-amount {
            background: #27ae60;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .file-input {
            display: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 600;
            text-align: center;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            /* increased modal width from 600px to 800px */
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .form-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-row .form-group {
            flex: 1;
            margin-bottom: 0;
        }

        .pattern-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .pattern-input input {
            width: 60px;
            text-align: center;
        }

        .bet-option {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .bet-option input[type="checkbox"] {
            transform: scale(1.2);
        }

        .bet-option input[type="number"] {
            width: 150px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }

            .content {
                padding: 20px;
            }

            .buttons {
                flex-direction: column;
            }

            .rule-header {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }

            .form-row {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üê≤ SƒÉn R·ªìng</h1>
            <p>C·∫•u h√¨nh Game v√† Chi·∫øn thu·∫≠t C∆∞·ª£c</p>
        </div>

        <div class="content">
            <div class="section">
                <h2>‚öôÔ∏è C√†i ƒë·∫∑t Game</h2>
                <div class="form-group">
                    <label>üí∞ S·ªë ti·ªÅn c∆∞·ª£c m·ªói l·∫ßn:</label>
                    <input type="number" id="betAmount" value="1000" min="100" step="100">
                </div>
                <div class="form-group">
                    <label>üé∞ Ng∆∞·ª°ng Jackpot:</label>
                    <input type="number" id="jackpotThreshold" value="500000" min="10000" step="10000">
                </div>
                <div class="form-group">
                    <label>üõë D·ª´ng c∆∞·ª£c khi thua:</label>
                    <input type="number" id="betStop" value="10000" min="1000" step="1000">
                </div>
                <div class="form-group">
                    <label>‚è±Ô∏è Th·ªùi gian g·ª≠i tin nh·∫Øn (gi√¢y):</label>
                    <input type="number" id="timeSendMess" value="1" min="1" max="10">
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="isMartingale">
                        <label for="isMartingale">üìà S·ª≠ d·ª•ng chi·∫øn thu·∫≠t Martingale</label>
                    </div>
                </div>
                <div class="form-group">
                    <label>üìä T·ª∑ l·ªá Martingale:</label>
                    <input type="number" id="rateMartingale" value="2" min="1.5" max="5" step="0.1">
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="zombie" checked>
                        <label for="zombie">üßü Ch·∫ø ƒë·ªô Zombie (t·ª± ƒë·ªông)</label>
                    </div>
                </div>
            </div>

            <div class="section betting-rules">
                <h2>üéØ Quy t·∫Øc c∆∞·ª£c</h2>
            </div>

            <div class="buttons">
                <button class="btn btn-success" onclick="saveConfig()">
                    üíæ L∆∞u c·∫•u h√¨nh
                </button>
                <button class="btn btn-danger" onclick="resetConfig()">
                    üîÑ Reset v·ªÅ m·∫∑c ƒë·ªãnh
                </button>
            </div>

            <input type="file" id="configFileInput" class="file-input" accept=".json"
                onchange="loadConfigFromFile(event)">

            <div id="status" class="status"></div>
        </div>
    </div>

    <!-- Add/Edit Rule Modal -->
    <div id="ruleModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">‚ûï Th√™m quy t·∫Øc c∆∞·ª£c m·ªõi</h2>
                <span class="close" onclick="closeAddRuleForm()">&times;</span>
            </div>

            <form id="ruleForm">
                <div class="form-group">
                    <label>üìù M√¥ t·∫£ quy t·∫Øc:</label>
                    <input type="text" id="ruleDescription" placeholder="V√≠ d·ª•: C∆∞·ª£c H∆ØU khi c√≥ pattern H∆ØU-B·∫¶U"
                        required>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>üî¢ ƒê·ªô ∆∞u ti√™n:</label>
                        <input type="number" id="rulePriority" value="1" min="1" max="10">
                    </div>
                </div>

                <div class="form-group">
                    <label>üé≤ Pattern v·ªã tr√≠ (t√πy ch·ªçn):</label>
                    <div id="patternInputs">
                        <!-- Pattern inputs will be dynamically generated here -->
                    </div>
                    <small>Nh·∫•p v√†o H∆ØU, B·∫¶U, G√Ä, C√Å, CUA ho·∫∑c T√îM ƒë·ªÉ th√™m v√†o pattern. T·ªëi ƒëa 10 v·ªã tr√≠.</small>
                </div>

                <div class="form-group">
                    <label>üéØ Lo·∫°i c∆∞·ª£c:</label>
                    <div id="betOptions">
                        <!-- Bet options will be dynamically generated here -->
                    </div>
                </div>

                <div class="buttons">
                    <button type="button" class="btn btn-success" onclick="saveRule()">üíæ L∆∞u quy t·∫Øc</button>
                    <button type="button" class="btn btn-danger" onclick="closeAddRuleForm()">‚ùå H·ªßy</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const API_BASE_URL = "http://localhost:3000/api/config/fish-prawn-crab";
        const AVAILABLE_COLORS = ["H∆ØU", "B·∫¶U", "G√Ä", "C√Å", "CUA", "T√îM"];
        const MAX_PATTERN_POSITIONS = 10; // Maximum number of 3-dice groups
        const DICE_PER_POSITION = 3; // Each position has 3 dice

        const BET_OPTIONS = [
            { label: "H∆∞u", value: "0" },
            { label: "B·∫ßu", value: "1" },
            { label: "G√†", value: "2" },
            { label: "C√°", value: "3" },
            { label: "Cua", value: "4" },
            { label: "T√¥m", value: "5" }
        ];

        let currentConfig = {
            gameSettings: {},
            bettingRules: []
        };
        let editingRuleIndex = -1;
        let currentPattern = []; // Array of arrays, each inner array has 3 symbols
        let currentDiceGroup = []; // Temporary storage for current group being built

        document.addEventListener('DOMContentLoaded', function () {
            loadConfigFromServer();
            setupFormSync();
        });

        // --- Load config t·ª´ server ---
        async function loadConfigFromServer() {
            try {
                const response = await fetch(API_BASE_URL);
                if (!response.ok) throw new Error("Kh√¥ng th·ªÉ t·∫£i config t·ª´ server");

                const config = await response.json();
                currentConfig = config;
                updateFormFromConfig(config);
                updateBettingRulesDisplay(config.bettingRules || []);

                showStatus("‚úÖ ƒê√£ t·∫£i c·∫•u h√¨nh t·ª´ server!", "success");
            } catch (error) {
                currentConfig = {
                    gameSettings: {
                        "BET_AMOUNT": 1000,
                        "JACKPOT_THRESHOLD": 500000,
                        "BET_STOP": 10000,
                        "TIME_SEND_MESS": 1,
                        "IS_MARTINGALE": false,
                        "RATE_MARTINGALE": 2,
                        "ZOMBIE": true
                    },
                    bettingRules: [
                        {
                            "betOn": ["0"],
                            "priority": 10,
                            "active": true,
                            "description": "H∆ØU-B·∫¶U-G√Ä ‚Üí C√Å-CUA-T√îM c∆∞·ª£c H∆ØU",
                            "betAmount": [5000],
                            "pattern": [["H∆ØU", "B·∫¶U", "G√Ä"], ["C√Å", "CUA", "T√îM"]]
                        },
                        {
                            "betOn": ["0", "1"],
                            "priority": 0,
                            "active": true,
                            "description": "Default rule: n·∫øu kh√¥ng kh·ªõp pattern n√†o th√¨ c∆∞·ª£c H∆ØU v√† B·∫¶U.",
                            "betAmount": [1000, 2000],
                            "pattern": []
                        }
                    ]
                };
                updateFormFromConfig(currentConfig);
                updateBettingRulesDisplay(currentConfig.bettingRules);
                showStatus("‚ö†Ô∏è S·ª≠ d·ª•ng c·∫•u h√¨nh m·∫∑c ƒë·ªãnh (kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c server)", "error");
            }
        }

        function updateFormFromConfig(config) {
            const settings = config.gameSettings;
            document.getElementById('betAmount').value = settings.BET_AMOUNT || 1000;
            document.getElementById('jackpotThreshold').value = settings.JACKPOT_THRESHOLD || 500000;
            document.getElementById('betStop').value = settings.BET_STOP || 10000;
            document.getElementById('timeSendMess').value = settings.TIME_SEND_MESS || 1;
            document.getElementById('isMartingale').checked = settings.IS_MARTINGALE || false;
            document.getElementById('rateMartingale').value = settings.RATE_MARTINGALE || 2;
            document.getElementById('zombie').checked = settings.ZOMBIE !== false;
        }

        function updateConfigFromForm() {
            currentConfig.gameSettings = {
                "BET_AMOUNT": parseInt(document.getElementById('betAmount').value),
                "JACKPOT_THRESHOLD": parseInt(document.getElementById('jackpotThreshold').value),
                "BET_STOP": parseInt(document.getElementById('betStop').value),
                "TIME_SEND_MESS": parseInt(document.getElementById('timeSendMess').value),
                "IS_MARTINGALE": document.getElementById('isMartingale').checked,
                "RATE_MARTINGALE": parseFloat(document.getElementById('rateMartingale').value),
                "ZOMBIE": document.getElementById('zombie').checked
            };
        }

        // --- Save config v·ªÅ server ---
        async function saveConfig() {
            try {
                updateConfigFromForm();

                const response = await fetch(API_BASE_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(currentConfig, null, 4)
                });

                if (!response.ok) throw new Error("Server tr·∫£ l·ªói");

                showStatus("‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh th√†nh c√¥ng l√™n server!", "success");
            } catch (error) {
                showStatus("‚ùå L·ªói khi l∆∞u: " + error.message, "error");
            }
        }

        // --- Reset config ---
        async function resetConfig() {
            if (!confirm("üîÑ B·∫°n c√≥ ch·∫Øc mu·ªën reset v·ªÅ c·∫•u h√¨nh m·∫∑c ƒë·ªãnh?")) return;
            try {
                const response = await fetch(API_BASE_URL + "/reset", { method: "POST" });
                if (!response.ok) throw new Error("Server tr·∫£ l·ªói reset");

                const defaultConfig = await response.json();
                currentConfig = defaultConfig;
                updateFormFromConfig(defaultConfig);
                updateBettingRulesDisplay(defaultConfig.bettingRules || []);

                showStatus("üîÑ ƒê√£ reset v·ªÅ c·∫•u h√¨nh m·∫∑c ƒë·ªãnh t·ª´ server!", "success");
            } catch (error) {
                // Fallback reset
                currentConfig.bettingRules = [];
                updateBettingRulesDisplay([]);
                showStatus("üîÑ ƒê√£ x√≥a t·∫•t c·∫£ quy t·∫Øc c∆∞·ª£c!", "success");
            }
        }

        // --- Betting Rules Management ---
        function updateBettingRulesDisplay(bettingRules) {
            const bettingSection = document.querySelector('.betting-rules');
            const existingRules = bettingSection.querySelectorAll('.rule-item');
            existingRules.forEach(rule => rule.remove());

            // Remove existing add button
            const existingAddBtn = bettingSection.querySelector('.btn-primary');
            if (existingAddBtn) existingAddBtn.remove();

            bettingRules.forEach((rule, index) => {
                const ruleDiv = document.createElement('div');
                ruleDiv.className = 'rule-item';
                const patternDisplay = rule.pattern && rule.pattern.length > 0 ? `
                    <p><strong>Pattern v·ªã tr√≠ (m·ªói v·ªã tr√≠ 3 x√∫c x·∫Øc):</strong></p>
                    <div class="pattern-display" style="display: flex; gap: 15px; flex-wrap: wrap;">
                        ${rule.pattern.map((group, groupIndex) => `
                            <div style="display: flex; flex-direction: column; gap: 5px; align-items: center;">
                                <span style="font-size: 12px; color: #6c757d; font-weight: bold;">V·ªã tr√≠ ${groupIndex + 1}</span>
                                <div style="display: flex; gap: 3px; padding: 8px; background: #f8f9fa; border-radius: 8px; border: 2px solid #e9ecef;">
                                    ${Array.isArray(group) ? group.map(color => `
                                        <span class="pattern-item" style="background-color: ${getColorCode(color)}; padding: 8px 12px; font-size: 13px;">${color}</span>
                                    `).join('') : `<span class="pattern-item" style="background-color: ${getColorCode(group)}">${group}</span>`}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : '<p><strong>Pattern:</strong> Kh√¥ng c√≥ pattern c·ª• th·ªÉ</p>';

                ruleDiv.innerHTML = `
                    <div class="rule-header">
                        <h3>Quy t·∫Øc ${index + 1} ${rule.active ? '‚úÖ' : '‚ùå'}</h3>
                        <div>
                            <span class="priority-badge">∆Øu ti√™n: ${rule.priority}</span>
                            <button class="btn btn-warning" onclick="editRule(${index})" style="padding: 5px 10px; font-size: 12px; margin-left: 10px;">‚úèÔ∏è S·ª≠a</button>
                            <button class="btn btn-danger" onclick="deleteRule(${index})" style="padding: 5px 10px; font-size: 12px; margin-left: 5px;">üóëÔ∏è X√≥a</button>
                        </div>
                    </div>
                    <p><strong>M√¥ t·∫£:</strong> ${rule.description}</p>
                    ${patternDisplay}
                    <p><strong>C∆∞·ª£c v√†o:</strong> ${Array.isArray(rule.betOn) ? rule.betOn.map(option => option.split('_')[0]).join(', ') : rule.betOn.split('_')[0]}</p>
                    <div class="bet-amounts">
                        ${Array.isArray(rule.betAmount) ?
                        rule.betAmount.map((amount, i) => `<span class="bet-amount">${Array.isArray(rule.betOn) ? rule.betOn[i].split('_')[0] : 'C∆∞·ª£c'}: ${amount.toLocaleString()} VNƒê</span>`).join('') :
                        `<span class="bet-amount">${rule.betAmount.toLocaleString()} VNƒê</span>`
                    }
                    </div>
                `;
                bettingSection.appendChild(ruleDiv);
            });

            const addRuleBtn = document.createElement('button');
            addRuleBtn.className = 'btn btn-primary';
            addRuleBtn.innerHTML = '‚ûï Th√™m quy t·∫Øc c∆∞·ª£c m·ªõi';
            addRuleBtn.onclick = showAddRuleForm;
            bettingSection.appendChild(addRuleBtn);
        }

        function getColorCode(colorName) {
            const colorMap = {
                'H∆ØU': '#8B4513',      // Brown for Deer (H∆∞u)
                'B·∫¶U': '#27ae60',      // Green for Gourd (B·∫ßu)
                'G√Ä': '#e74c3c',       // Red for Rooster (G√†)
                'C√Å': '#3498db',       // Blue for Fish (C√°)
                'CUA': '#f39c12',      // Orange for Crab (Cua)
                'T√îM': '#e91e63',      // Pink for Shrimp (T√¥m)
            };
            return colorMap[colorName] || '#95a5a6';
        }

        function showAddRuleForm() {
            editingRuleIndex = -1;
            document.getElementById('modalTitle').textContent = '‚ûï Th√™m quy t·∫Øc c∆∞·ª£c m·ªõi';
            clearRuleForm();
            updatePatternInputs();
            updateBetOptions();
            document.getElementById('ruleModal').style.display = 'block';
        }

        function updatePatternInputs() {
            const patternContainer = document.getElementById('patternInputs');
            patternContainer.innerHTML = `
                <div class="pattern-input">
                    <label>Ch·ªçn pattern (m·ªói v·ªã tr√≠ g·ªìm 3 x√∫c x·∫Øc) - t·ªëi ƒëa ${MAX_PATTERN_POSITIONS} v·ªã tr√≠:</label>
                    <div id="selectedPattern" style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0; min-height: 60px; border: 2px dashed #e9ecef; border-radius: 8px; padding: 15px; align-items: flex-start;">
                        <span id="patternPlaceholder" style="color: #6c757d; font-style: italic;">Nh·∫•p v√†o c√°c bi·ªÉu t∆∞·ª£ng b√™n d∆∞·ªõi ƒë·ªÉ t·∫°o pattern. M·ªói v·ªã tr√≠ c·∫ßn 3 x√∫c x·∫Øc...</span>
                    </div>
                    <div id="currentDiceGroup" style="display: flex; gap: 5px; margin: 10px 0; padding: 10px; background: #fff3cd; border-radius: 8px; border: 2px solid #ffc107; min-height: 50px; align-items: center;">
                        <span style="font-weight: bold; color: #856404; margin-right: 10px;">ƒêang ch·ªçn v·ªã tr√≠ ${currentPattern.length + 1}:</span>
                        <div id="diceGroupDisplay" style="display: flex; gap: 5px; flex: 1; align-items: center;">
                            <span style="color: #856404; font-style: italic;">Ch·ªçn 3 x√∫c x·∫Øc cho v·ªã tr√≠ n√†y...</span>
                        </div>
                    </div>
                    <div id="colorPalette" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;">
                        ${AVAILABLE_COLORS.map(color => `
                            <button type="button" class="color-btn" data-color="${color}" 
                                style="background-color: ${getColorCode(color)}; 
                                       color: white; 
                                       border: 3px solid transparent;
                                       padding: 15px 25px; 
                                       border-radius: 8px; 
                                       font-weight: bold; 
                                       cursor: pointer;
                                       transition: all 0.3s;
                                       min-width: 100px;
                                       font-size: 16px;"
                                onclick="addColorToPattern('${color}')"
                                onmouseover="this.style.transform='scale(1.05)'"
                                onmouseout="this.style.transform='scale(1)'">${color}</button>
                        `).join('')}
                    </div>
                    <small>M·ªói v·ªã tr√≠ c·∫ßn ch·ªçn ƒë·ªß 3 x√∫c x·∫Øc. T·ªëi ƒëa ${MAX_PATTERN_POSITIONS} v·ªã tr√≠.</small>
                </div>
            `;
        }

        function updateBetOptions() {
            const betOptionsContainer = document.getElementById('betOptions');
            betOptionsContainer.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <label><strong>Ch·ªçn lo·∫°i c∆∞·ª£c v·ªõi t·ª∑ l·ªá:</strong></label>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                        ${BET_OPTIONS.map(option => `
                            <div class="bet-option" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 2px solid #e9ecef;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="checkbox" id="bet${option.value}" value="${option.value}" style="transform: scale(1.3);">
                                    <label for="bet${option.value}" style="margin: 0; min-width: 150px; font-weight: bold; font-size: 14px;">
                                        ${option.label}
                                    </label>
                                    <input type="number" id="amount${option.value}" placeholder="S·ªë ti·ªÅn c∆∞·ª£c" min="1000" step="1000" style="flex: 1; padding: 10px; border: 2px solid #e9ecef; border-radius: 8px; font-size: 14px;">
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function addColorToPattern(color) {
            if (currentPattern.length >= MAX_PATTERN_POSITIONS && currentDiceGroup.length === 0) {
                alert(`Ch·ªâ ƒë∆∞·ª£c ch·ªçn t·ªëi ƒëa ${MAX_PATTERN_POSITIONS} v·ªã tr√≠ cho pattern!`);
                return;
            }

            console.log("[v0] Adding color to dice group:", color);
            currentDiceGroup.push(color);
            console.log("[v0] Current dice group:", currentDiceGroup);

            // When we have 3 dice, complete the group and add to pattern
            if (currentDiceGroup.length === DICE_PER_POSITION) {
                currentPattern.push([...currentDiceGroup]);
                console.log("[v0] Completed dice group, added to pattern:", currentPattern);
                currentDiceGroup = [];
            }

            updatePatternDisplay();
            updatePatternDescription();
        }

        function updatePatternDisplay() {
            const patternContainer = document.getElementById('selectedPattern');
            const placeholder = document.getElementById('patternPlaceholder');
            const diceGroupDisplay = document.getElementById('diceGroupDisplay');
            const currentDiceGroupContainer = document.getElementById('currentDiceGroup');

            console.log("[v0] Updating pattern display, current pattern:", currentPattern);
            console.log("[v0] Current dice group:", currentDiceGroup);

            // Remove existing pattern items first
            const existingItems = patternContainer.querySelectorAll('.pattern-position-item');
            existingItems.forEach(item => item.remove());

            if (currentPattern.length === 0 && currentDiceGroup.length === 0) {
                console.log("[v0] No pattern items, showing placeholder");
                if (placeholder) {
                    placeholder.style.display = 'block';
                }
            } else {
                if (placeholder) {
                    placeholder.style.display = 'none';
                }
            }

            // Display completed positions (groups of 3)
            currentPattern.forEach((group, positionIndex) => {
                const positionItem = document.createElement('div');
                positionItem.className = 'pattern-position-item';
                positionItem.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    gap: 5px;
                    align-items: center;
                    background: #f8f9fa;
                    padding: 10px;
                    border-radius: 8px;
                    border: 2px solid #dee2e6;
                `;

                const positionLabel = document.createElement('div');
                positionLabel.style.cssText = `
                    font-size: 12px;
                    color: #6c757d;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                `;
                positionLabel.innerHTML = `
                    <span>V·ªã tr√≠ ${positionIndex + 1}</span>
                    <button type="button" onclick="removePositionFromPattern(${positionIndex})" 
                        style="background: #dc3545; border: none; border-radius: 50%; width: 18px; height: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; color: white; font-weight: bold;">√ó</button>
                `;

                const diceContainer = document.createElement('div');
                diceContainer.style.cssText = `
                    display: flex;
                    gap: 3px;
                `;

                group.forEach((color) => {
                    const diceItem = document.createElement('div');
                    diceItem.style.cssText = `
                        background-color: ${getColorCode(color)};
                        color: white;
                        padding: 8px 12px;
                        border-radius: 6px;
                        font-weight: bold;
                        font-size: 13px;
                    `;
                    diceItem.textContent = color;
                    diceContainer.appendChild(diceItem);
                });

                positionItem.appendChild(positionLabel);
                positionItem.appendChild(diceContainer);
                patternContainer.appendChild(positionItem);
            });

            // Update current dice group display
            if (diceGroupDisplay) {
                diceGroupDisplay.innerHTML = '';

                if (currentDiceGroup.length === 0) {
                    diceGroupDisplay.innerHTML = '<span style="color: #856404; font-style: italic;">Ch·ªçn 3 x√∫c x·∫Øc cho v·ªã tr√≠ n√†y...</span>';
                } else {
                    currentDiceGroup.forEach((color, index) => {
                        const diceItem = document.createElement('div');
                        diceItem.style.cssText = `
                            background-color: ${getColorCode(color)};
                            color: white;
                            padding: 8px 12px;
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 13px;
                            display: flex;
                            align-items: center;
                            gap: 5px;
                        `;
                        diceItem.innerHTML = `
                            <span>${color}</span>
                            <button type="button" onclick="removeDiceFromCurrentGroup(${index})" 
                                style="background: rgba(255,255,255,0.3); border: none; border-radius: 50%; width: 18px; height: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; color: white; font-weight: bold;">√ó</button>
                        `;
                        diceGroupDisplay.appendChild(diceItem);
                    });

                    // Show remaining slots
                    const remainingSlots = DICE_PER_POSITION - currentDiceGroup.length;
                    for (let i = 0; i < remainingSlots; i++) {
                        const emptySlot = document.createElement('div');
                        emptySlot.style.cssText = `
                            width: 60px;
                            height: 38px;
                            border: 2px dashed #ffc107;
                            border-radius: 6px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: #856404;
                            font-size: 20px;
                        `;
                        emptySlot.textContent = '?';
                        diceGroupDisplay.appendChild(emptySlot);
                    }
                }
            }

            // Update current dice group label
            if (currentDiceGroupContainer) {
                const label = currentDiceGroupContainer.querySelector('span');
                if (label) {
                    label.textContent = `ƒêang ch·ªçn v·ªã tr√≠ ${currentPattern.length + 1}:`;
                }
            }

            console.log("[v0] Pattern display updated");
        }

        function removeDiceFromCurrentGroup(index) {
            console.log("[v0] Removing dice at index:", index, "from current group:", currentDiceGroup);
            currentDiceGroup.splice(index, 1);
            console.log("[v0] Current dice group after removal:", currentDiceGroup);
            updatePatternDisplay();
            updatePatternDescription();
        }

        function removePositionFromPattern(positionIndex) {
            console.log("[v0] Removing position at index:", positionIndex, "Current pattern:", currentPattern);
            currentPattern.splice(positionIndex, 1);
            console.log("[v0] Pattern after removal:", currentPattern);

            updatePatternDisplay();
            updatePatternDescription();
        }

        function updatePatternDescription() {
            console.log("[v0] updatePatternDescription called, currentPattern:", currentPattern);
            const descriptionInput = document.getElementById('ruleDescription');
            if (!descriptionInput) {
                console.log("[v0] Description input not found");
                return;
            }

            if (currentPattern.length > 0 || currentDiceGroup.length > 0) {
                const completedGroups = currentPattern.map(group => group.join('-'));
                const allGroups = [...completedGroups];

                if (currentDiceGroup.length > 0) {
                    allGroups.push(currentDiceGroup.join('-') + '...');
                }

                const patternDescription = allGroups.join(' ‚Üí ');
                console.log("[v0] Pattern description generated:", patternDescription);
                descriptionInput.value = patternDescription;
                console.log("[v0] Description field updated:", descriptionInput.value);
            } else {
                descriptionInput.value = '';
                console.log("[v0] Description cleared for empty pattern");
            }
        }

        function saveRule() {
            const description = document.getElementById('ruleDescription').value.trim();
            const priority = parseInt(document.getElementById('rulePriority').value);

            if (!description) {
                alert('Vui l√≤ng nh·∫≠p m√¥ t·∫£ quy t·∫Øc!');
                return;
            }

            if (currentDiceGroup.length > 0) {
                alert(`Vui l√≤ng ho√†n th√†nh v·ªã tr√≠ hi·ªán t·∫°i! C·∫ßn ch·ªçn th√™m ${DICE_PER_POSITION - currentDiceGroup.length} x√∫c x·∫Øc n·ªØa.`);
                return;
            }

            // Use currentPattern (array of arrays)
            const selectedPatternColors = [...currentPattern];

            const betOn = [];
            const betAmount = [];

            BET_OPTIONS.forEach(option => {
                const checkbox = document.getElementById(`bet${option.value}`);
                const amountInput = document.getElementById(`amount${option.value}`);

                if (checkbox && checkbox.checked && amountInput && amountInput.value) {
                    betOn.push(option.value);
                    betAmount.push(parseInt(amountInput.value));
                }
            });

            if (betOn.length === 0) {
                alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt lo·∫°i c∆∞·ª£c v√† nh·∫≠p s·ªë ti·ªÅn!');
                return;
            }

            const flatPattern = selectedPatternColors.map(group => group.join('-'));

            const newRule = {
                description: description,
                priority: priority,
                active: true,
                pattern: flatPattern,
                betOn: betOn, // Always keep as array
                betAmount: betAmount // Always keep as array
            };

            if (editingRuleIndex >= 0) {
                // Edit existing rule
                currentConfig.bettingRules[editingRuleIndex] = newRule;
                showStatus('‚úÖ ƒê√£ c·∫≠p nh·∫≠t quy t·∫Øc c∆∞·ª£c!', 'success');
            } else {
                // Add new rule
                if (!currentConfig.bettingRules) currentConfig.bettingRules = [];
                currentConfig.bettingRules.push(newRule);
                showStatus('‚úÖ ƒê√£ th√™m quy t·∫Øc c∆∞·ª£c m·ªõi!', 'success');
            }

            // Sort rules by priority (higher priority first)
            currentConfig.bettingRules.sort((a, b) => b.priority - a.priority);

            updateBettingRulesDisplay(currentConfig.bettingRules);
            closeAddRuleForm();
        }

        function editRule(index) {
            editingRuleIndex = index;
            const rule = currentConfig.bettingRules[index];

            document.getElementById('modalTitle').textContent = '‚úèÔ∏è S·ª≠a quy t·∫Øc c∆∞·ª£c';
            document.getElementById('ruleDescription').value = rule.description;
            document.getElementById('rulePriority').value = rule.priority;

            updatePatternInputs();
            updateBetOptions();

            currentPattern = rule.pattern ? rule.pattern.map(group =>
                Array.isArray(group) ? [...group] : [group]
            ) : [];
            currentDiceGroup = [];
            updatePatternDisplay();

            const betOn = Array.isArray(rule.betOn) ? rule.betOn : [rule.betOn];
            const betAmount = Array.isArray(rule.betAmount) ? rule.betAmount : [rule.betAmount];

            betOn.forEach((betValue, i) => {
                const checkbox = document.getElementById(`bet${betValue}`);
                const amountInput = document.getElementById(`amount${betValue}`);
                if (checkbox) checkbox.checked = true;
                if (amountInput) amountInput.value = betAmount[i] || betAmount[0];
            });

            document.getElementById('ruleModal').style.display = 'block';
        }

        function closeAddRuleForm() {
            document.getElementById('ruleModal').style.display = 'none';
            clearRuleForm();
        }

        function clearRuleForm() {
            document.getElementById('ruleForm').reset();
            document.getElementById('rulePriority').value = 1;
            currentPattern = [];
            currentDiceGroup = [];
            if (document.getElementById('selectedPattern')) {
                updatePatternDisplay();
            }
        }

        function deleteRule(index) {
            if (!confirm('üóëÔ∏è B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a quy t·∫Øc n√†y?')) return;

            currentConfig.bettingRules.splice(index, 1);
            updateBettingRulesDisplay(currentConfig.bettingRules);
            showStatus('üóëÔ∏è ƒê√£ x√≥a quy t·∫Øc c∆∞·ª£c!', 'success');
        }

        // --- Form sync ---
        function setupFormSync() {
            const formInputs = [
                'betAmount', 'jackpotThreshold', 'betStop', 'timeSendMess',
                'isMartingale', 'rateMartingale', 'zombie'
            ];
            formInputs.forEach(inputId => {
                const element = document.getElementById(inputId);
                if (element) {
                    element.addEventListener('input', function () {
                        clearTimeout(window.formSyncTimeout);
                        window.formSyncTimeout = setTimeout(() => {
                            updateConfigFromForm();
                        }, 500);
                    });
                }
            });
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            setTimeout(() => { statusDiv.style.display = 'none'; }, 5000);
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('ruleModal');
            if (event.target === modal) {
                closeAddRuleForm();
            }
        }
    </script>
</body>

</html>